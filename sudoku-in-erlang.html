<!DOCTYPE html>
<html >
  <head > <link  rel="stylesheet" type="text/css" href="media/myblog.css">
</link><link  rel="stylesheet" type="text/css" href="media/pygments.css">

</link>
  <link  type="text/css" href="http://fonts.googleapis.com/css?family=Inconsolata" type="rel='stylesheet'">

</link><style   type="text/css">
  body {
    font-family: Inconsolata;
  }
</style>
  </head><body >
    <div  id="page">
      <div  id="header"> <nav >
  <a  href="index.html">home</a><a  href="http://in.linkedin.com/in/prataprc">linkedin</a><a  href="https://github.com/prataprc">github</a></nav></div>
      <div  id="container">
        
          <article > <div  class="title"> Sudoku on erlang</div>
  <div  class="pagemeta">
    <span  class="author"> by prataprc -</span>
    <span  class="date"> Sun Jul 2, 2013</span></div>

  <div  class="content"> <div class="section" id="why-erlang">
<h1>Why erlang ?</h1>
<p>For past three decades the semiconductor industry promised to double the speed
of microprocessor every two years, and they did kept to their promise. Now, it
looks like they have exhausted all the available tricks and the only way to
increase computation speed is by going parallel - packing more number of cores
in the same die. But that ain't so easy, for it requires re-designing our
algorithms to run parallel. Enter concurrent programming.</p>
<p>Concurrent programming is a paradigm of writing computer programs that can
execute in parallel. Three decades of structured programming concepts
popularized by languages like C and Java have made the entire eco-system of
computer applications optimized for sequential programming. Now, even when we
are ready to redesign our algorithms for concurrency, its implementation,
testing and deployment are making life difficult for us. The general focus on
Erlang here is that it may save us from some of those difficulties.</p>
</div>
<div class="section" id="why-sudoku">
<h1>Why sudoku ?</h1>
<p>After going through the language specifications, it was clear that the language
is most suited for server applications and applications that are naturally
suited for concurrency, like Twitterfall. So I decided to pick computationally
intensive algorithm that is also complex enough. My choice was to implement a
<a class="reference external" href="http://en.wikipedia.org/wiki/Sudoku">sudoku</a> puzzle solver.</p>
</div>
<div class="section" id="to-the-algorithm">
<h1>To the algorithm</h1>
<p>This backtracking algorithm, that solves sudoku puzzle has exponential
complexity and one can introduce pathological combinations throwing the program
into a for-ever-loop. By tweaking the input combination and few other parameters
we can adjust the complexity of the problem and study the behavior of the
language and its run-time. Download the source code and experiment with it.</p>
<p>The program takes an unsolved sudoku puzzle with N elements pre-populated -
that is, say for a 9x9 table of numbers, may be just 10 can be pre-populated. The
number of elements that are pre-populated can also be supplied as a parameter.
The algorithm itself uses a double recursive backtracking logic to find the
right combination of numbers satisfying the game rules. So, for a 9x9 table
with 10 pre-populated elements, the program must fill the remaining 71 slots
and for each slot there are 9 choices ([1,2,3,4,5,6,7,8,9]).</p>
<p>The first recursion logic moves from one slot to the next, column-wise and
then row-wise. At every step, it tries to reduce the available choices for an
unfilled slot. There are 6 intelligent functors that applies primitive human
logic to reduce the choices. It then detects whether it has taken the right
path by checking with the game rules. If it detects that it has taken a bad
path it backtracks.</p>
<p>The second recursion logic kicks in when the first recursive function detects
that it has taken the right path (so far), and finds that the current slot has
more than one choice left un-reducible. The logic will recur over each of the
available choices by calling back to first recursion logic. So on and so
forth ...</p>
<p>Let us have some hands on with the code now,</p>
<div class="highlight"><pre><span class="c"># solve a single sudoku puzzle of complexity 3 (9x9) and difficulty 40%</span>
<span class="nv">$ </span>bin/sudoku -c 3 -d 40 -s 1123
complexity:3 count:1 difficulty:40 seed:1123
Time taken to evaluate 53528uS
</pre></div>
<p>Above, sudoku script generates a 9x9 puzzle populating 40% of the slots and
took 53 milli-seconds to solve the puzzle. The <cite>-s</cite> option provides the seed
value to random-generator, so that same set of puzzles will be generated for the
same seed value. Note that the puzzled is solved using a sequential backtracking
algorithm explained above.</p>
<p><cite>All measurements are taken with my 1.6Ghz atom-netbook</cite>.</p>
<p>Using the same parameters but solving 100 puzzles - <cite>sequentially</cite>,</p>
<div class="highlight"><pre><span class="c"># solve a single sudoku puzzle of complexity 3 (9x9) and difficulty 40%</span>
<span class="nv">$ </span>bin/sudoku -c 3 -d 40 -s 1123 -n 100
complexity:3 count:100 difficulty:40 seed:1123
Time taken to evaluate 4741382uS
</pre></div>
<p>took about 5.7 seconds !</p>
<p>This type of algorithm is necessary to check how friendly is Erlang in
designing complex algorithms with concurrency.  And of course its performance.
But before that we will see how easy and efficient it is to get started with
concurrent programming in Erlang.</p>
</div>
<div class="section" id="simple-concurrency-with-erlang">
<h1>simple concurrency with erlang</h1>
<p>Before we transform the algorithm into a concurrent one, we will try
to measure how simple-concurrency, like what we see with web-servers serving
simultaneous requests, fair with erlang. The objective here is to solve large
number of puzzles, first sequentially one after the other, next concurrently
spawning a process for each puzzle. Thus we measure its scalability and
efficiency.</p>
<div class="highlight"><pre><span class="nv">$ </span>bin/sudoku -c 3 -n 100 -d 60 -s 1123 -benchmark
</pre></div>
<p>Above command generates puzzles of complexity 3, 9x9 sudoku table, populating
60% of the slots. Same seed value will generate same set of tables. The script
outputs three columns,
* first column - no. of puzzles sovled,
* second-column - time taken to solve sequentially,
* third-column - time taken to solve parallel, one process for each puzzle.</p>
<p>Unlike sequential logic, concurrent program execution can be bench marked with
multiple cores to measure its efficiency. In this case I have used my dual
core atom netbook (1.6Ghz). Following graph should give an idea on erlang's
efficiency and scalability.</p>
<img alt="media/sudokuerl_chart1.png" src="media/sudokuerl_chart1.png" />
</div></div></article></div></div>


    <hr ></hr>
    <div  id="footer"> <div  id="footer">
  &copy; 2013 Pratap Chakravarthy.</div></div></body>




</html>